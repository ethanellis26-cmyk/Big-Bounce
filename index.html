<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Big Bounce (Levels + Characters + Hotseat + Campaign)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    body { margin: 0; background: #111; color: #eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; overflow: hidden; touch-action: none; }
    .hud { padding: 10px 14px; text-align: center; }
    canvas { display: block; margin: 0 auto; background: #f8fafc; touch-action: none; }
    .hint { opacity: 0.85; font-size: 14px; margin-top: 6px; }
    .row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px; }
    button {
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
    }
    button.active {
      background: rgba(34, 197, 94, 0.22);
      border-color: rgba(34, 197, 94, 0.6);
    }
    button:disabled { opacity: 0.45; cursor: not-allowed; }

    /* Mobile touch controls */
    #touch-controls {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 140px;
      z-index: 100;
      pointer-events: none;
      padding: 0 12px 12px;
      box-sizing: border-box;
    }
    #touch-controls .tc-btn {
      pointer-events: auto;
      position: absolute;
      border: 2px solid rgba(255,255,255,0.35);
      background: rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.9);
      border-radius: 16px;
      font-weight: 700;
      font-size: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    #touch-controls .tc-btn:active, #touch-controls .tc-btn.pressed {
      background: rgba(255,255,255,0.30);
      border-color: rgba(34,197,94,0.7);
    }
    /* D-pad left side */
    #tc-left  { left: 12px;  bottom: 16px; width: 72px; height: 72px; }
    #tc-right { left: 96px;  bottom: 16px; width: 72px; height: 72px; }
    #tc-jump  { left: 54px;  bottom: 100px; width: 72px; height: 52px; font-size: 16px; }
    /* Action buttons right side */
    #tc-action { right: 12px; bottom: 16px; width: 100px; height: 100px; border-radius: 50%; background: rgba(34,197,94,0.18); border-color: rgba(34,197,94,0.5); font-size: 14px; text-align: center; line-height: 1.2; }
    #tc-reset  { right: 124px; bottom: 56px; width: 56px; height: 56px; border-radius: 50%; font-size: 16px; background: rgba(239,68,68,0.14); border-color: rgba(239,68,68,0.4); }

    @media (pointer: coarse), (max-width: 900px) {
      #touch-controls { display: block; }
      .hud { padding: 6px 8px; font-size: 12px; }
      .hud > div:first-child { font-size: 11px; }
      .hint { font-size: 11px; margin-top: 3px; }
      .row { gap: 4px; margin-top: 5px; }
      .row button { padding: 5px 7px; font-size: 11px; border-radius: 6px; }
      body { overflow: hidden; }
      canvas { max-height: calc(100vh - 220px); max-height: calc(100dvh - 220px); }
    }
  </style>
</head>
<body>
  <div class="hud">
    <div><b>Big Bounce</b> — Tap/Space to lock <b>Power</b>, then <b>Angle</b>. Move ← → to catch. Jump ↑</div>
    <div class="hint">Rules: bounce → wall-face (before roof) → catch. Roof-before-wall = 0. R = reset. Use on-screen buttons on mobile.</div>

    <div class="row">
      <button id="modeSingle">Single Player</button>
      <button id="modeMulti">Two Player</button>
      <button id="modeCampaign">Campaign</button>
      <button id="btnBegin" disabled>Begin</button>
    </div>

    <div class="row">
      <button id="btn0">Map 1: Townhouse</button>
      <button id="btn1">Map 2: Moon</button>
      <button id="btn2">Map 3: Berlin Wall</button>
      <button id="btn3">Map 4: Squash</button>
    </div>

    <div class="row">
      <button id="ch0">Brenden</button>
      <button id="ch1">Ethan</button>
      <button id="ch2">Xavier</button>
      <button id="ch3">Edward</button>
      <button id="ch4">Liam</button>
      <button id="ch5">Jake</button>
      <button id="ch6">Hans</button>
      <button id="ch7">Alex</button>
    </div>

    <div id="status" style="margin-top:10px;"></div>
  </div>

  <canvas id="c" width="1400" height="900"></canvas>

  <!-- Mobile on-screen controls -->
  <div id="touch-controls">
    <div id="tc-left"   class="tc-btn">&larr;</div>
    <div id="tc-right"  class="tc-btn">&rarr;</div>
    <div id="tc-jump"   class="tc-btn">&uarr; Jump</div>
    <div id="tc-action" class="tc-btn">Throw /<br>Lock</div>
    <div id="tc-reset"  class="tc-btn">R</div>
  </div>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const beginBtn = document.getElementById("btnBegin");

    // -----------------------------
    // World + Layout
    // -----------------------------
    const W = canvas.width;
    const H = canvas.height;

    const PANEL_W = 220;              // LEFT VERTICAL PANEL
    const playLeft = PANEL_W;         // gameplay starts here
    const floorY = H - 20;
    const wallX = W - 140;

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // -----------------------------
    // Game Mode
    // -----------------------------
    const Mode = Object.freeze({
      SINGLE: "SINGLE",
      MULTI: "MULTI",
      CAMPAIGN: "CAMPAIGN"
    });
    let gameMode = Mode.SINGLE;

    // -----------------------------
    // Single-player run config + timeout
    // -----------------------------
    const SINGLE_TURNS = 10;
    const SINGLE_SHOT_TIMEOUT_S = 8;
    let singleShotTimer = 0;

    // -----------------------------
    // Popups (big on-screen callouts)
    // -----------------------------
    const popup = { text: "", color: "#ffffff", size: 72, timer: 0, duration: 1.2 };

    function showPopup(text, opts = {}) {
      popup.text = text;
      popup.color = opts.color ?? "#ffffff";
      popup.size = opts.size ?? 72;
      popup.duration = opts.duration ?? 1.2;
      popup.timer = popup.duration;
    }
    function updatePopup(dt) { if (popup.timer > 0) popup.timer = Math.max(0, popup.timer - dt); }
    function drawPopup() {
      if (popup.timer <= 0 || !popup.text) return;

      const t = popup.timer / popup.duration; // 1 -> 0
      const alpha = Math.min(1, Math.max(0, t));

      const cx = playLeft + (W - playLeft) / 2;
      const cy = H * 0.22;

      ctx.save();
      ctx.globalAlpha = 0.15 + 0.85 * alpha;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `900 ${popup.size}px Trebuchet MS, system-ui`;

      ctx.lineWidth = 8;
      ctx.strokeStyle = "rgba(0,0,0,0.45)";
      ctx.strokeText(popup.text, cx, cy);

      ctx.fillStyle = popup.color;
      ctx.fillText(popup.text, cx, cy);
      ctx.restore();
    }

    // -----------------------------
    // Level Themes (themed arenas)
    // -----------------------------
    const THEMES = {
      townhouse: { bg: "#e5e7eb", floor: "#8b5a2b", wall: "#f5f5f4", roof: "#2a2a2a", ui: "#0f172a" },
      moon:      { bg: "#0b1020", floor: "#7a7a7a", wall: "#c7c7c7", roof: "#e5e7eb", ui: "#e5e7eb" },
      berlin:    { bg: "#93b7d6", floor: "#9ca3af", wall: "#374151", roof: "#000000", ui: "#0f172a" },
      squash:    { bg: "#6b7280", floor: "#b45309", wall: "#b91c1c", roof: "#7f1d1d", ui: "#0f172a" }
    };

    // -----------------------------
    // Levels
    // -----------------------------
    const LEVELS = [
      {
        id: 0, name: "Townhouse", roofType: "angled",
        roofLeftY: 450, roofRightY: 120,
        gravity: 1900, restitutionFloor: 0.80, restitutionWall: 0.85, restitutionRoof: 0.55,
        wallTopY: null, theme: THEMES.townhouse
      },
      {
        id: 1, name: "Moon", roofType: "none",
        roofY: 110,
        gravity: 700, restitutionFloor: 0.55, restitutionWall: 0.82, restitutionRoof: 0.50,
        wallTopY: null, theme: THEMES.moon
      },
      {
        id: 2, name: "Berlin Wall", roofType: "none",
        gravity: 2000, restitutionFloor: 0.88, restitutionWall: 0.87, restitutionRoof: 0.0,
        wallTopY: 0, theme: THEMES.berlin
      },
      {
        id: 3, name: "Squash", roofType: "flat",
        roofY: 60, gravity: 1850,
        restitutionFloor: 0.95, restitutionWall: 0.95, restitutionRoof: 0.85,
        wallTopY: 60, theme: THEMES.squash
      }
    ];

    const arena = {
      level: null,
      theme: THEMES.townhouse,
      roofType: "none",
      gravity: 1900,
      restitutionFloor: 0.80,
      restitutionWall: 0.85,
      restitutionRoof: 0.55,
      floorFriction: 0.987,
      airDrag: 0.999,
      wallTopY: 0,
      roofY: 0,
      roofLeftY: 0,
      roofRightY: 0
    };

    function roofAtX(x) {
      if (arena.roofType === "none") return -1e9;
      if (arena.roofType === "flat") return arena.roofY;
      const t = clamp((x - playLeft) / (wallX - playLeft), 0, 1);
      return arena.roofLeftY + (arena.roofRightY - arena.roofLeftY) * t;
    }

    // -----------------------------
    // Multiplayer (Hotseat)
    // -----------------------------
    const match = {
      enabled: false,
      started: false,
      roundsToWin: 7,
      roundNum: 1,
      roundStarter: 0,
      activeIndex: 0,
      winnerIndex: null,
      roundShots: [null, null],
      setupPickIndex: 0,
      firstPlayerScoredZeroThisRound: false,
      players: [
        { name: "P1", characterId: null, roundsWon: 0, lastThrow: null, throws: 0, sum: 0, walmart100s: 0, layups: 0, attempts: 0, catches: 0, best: null },
        { name: "P2", characterId: null, roundsWon: 0, lastThrow: null, throws: 0, sum: 0, walmart100s: 0, layups: 0, attempts: 0, catches: 0, best: null }
      ]
    };

    function resetPlayerStats(p) {
      p.throws = 0; p.sum = 0; p.walmart100s = 0; p.layups = 0; p.attempts = 0; p.catches = 0; p.best = null; p.lastThrow = null;
    }

    // -----------------------------
    // Campaign (Single-player vs Opponents)
    // -----------------------------
    const CAMPAIGN_OPPONENTS = [
      { name: "Hans",    avg: 50, sigma: 28, fault: 0.08 },
      { name: "Alex",    avg: 58, sigma: 24, fault: 0.06 },
      { name: "Liam",    avg: 65, sigma: 20, fault: 0.05 },
      { name: "Jake",    avg: 72, sigma: 16, fault: 0.04 },
      { name: "Xavier",  avg: 78, sigma: 13, fault: 0.03 },
      { name: "Edward",  avg: 83, sigma: 11, fault: 0.025 },
      { name: "Brenden", avg: 88, sigma:  9, fault: 0.02 },
      { name: "Ethan",   avg: 92, sigma:  7, fault: 0.015 }
    ];

    const campaign = {
      enabled: false,
      started: false,
      opponentIndex: 0,        // starts at Hans
      pointsToWin: 7,

      playerCharId: 0,
      oppCharId: null,

      // match state
      pScore: 0,
      oScore: 0,

      // point flow
      pointStarter: 0,         // 0 = Opponent first, 1 = Player first (alternates each POINT, ties replay)
      ghostScore: null,        // score for THIS point
      awaitingPlayerThrow: false,

      // opponent "hot/cold"
      moodDelta: 0,
      moodRemaining: 0,

      // end-of-match banner
      lastResult: null,        // "WIN" | "LOSE" | "COMPLETE"
      justAdvanced: false
    };

    function charIdByName(name) {
      const idx = CHARACTERS.findIndex(c => c.name === name);
      return idx >= 0 ? CHARACTERS[idx].id : 0;
    }

    function campaignOpponent() {
      return CAMPAIGN_OPPONENTS[clamp(campaign.opponentIndex, 0, CAMPAIGN_OPPONENTS.length - 1)];
    }

    function resetCampaignMatch(keepProgress = true) {
      if (!keepProgress) campaign.opponentIndex = 0;

      campaign.pScore = 0;
      campaign.oScore = 0;
      campaign.pointStarter = 0; // start with opponent first
      campaign.ghostScore = null;
      campaign.awaitingPlayerThrow = false;

      campaign.moodDelta = 0;
      campaign.moodRemaining = 0;

      campaign.lastResult = null;
      campaign.justAdvanced = false;

      const opp = campaignOpponent();
      campaign.oppCharId = charIdByName(opp.name);
    }

    function randomNormal() {
      // Box-Muller
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function generateGhostScore() {
      const opp = campaignOpponent();

      // Rare ceiling faults (independent, very rare)
      const rareCeilingFault = Math.random() < 0.005;

      // General "fault" chance (score 0)
      const generalFault = Math.random() < opp.fault;

      if (rareCeilingFault) {
        showPopup("Ceiling Fault", { size: 64, color: "#ffffff" });
        return 0;
      }
      if (generalFault) {
        if (Math.random() < 0.35) showPopup("Opponent Fault", { size: 56, color: "#ffffff" });
        return 0;
      }

      // occasional hot/cold mini-streaks
      if (campaign.moodRemaining <= 0) {
        const roll = Math.random();
        if (roll < 0.10) { campaign.moodDelta = +8; campaign.moodRemaining = 2 + Math.floor(Math.random() * 2); }      // hot
        else if (roll < 0.20) { campaign.moodDelta = -8; campaign.moodRemaining = 2 + Math.floor(Math.random() * 2); } // cold
        else { campaign.moodDelta = 0; campaign.moodRemaining = 0; }
      }

      const delta = campaign.moodDelta;
      if (campaign.moodRemaining > 0) campaign.moodRemaining--;

      const raw = (opp.avg + delta) + randomNormal() * opp.sigma;
      return clamp(Math.round(raw), 0, 100);
    }

    function beginCampaignMatch() {
      if (!canBeginGame()) return;

      campaign.started = true;
      resetCampaignMatch(true);
      setCampaignCurrentCharacter();
      startNewPoint();
      refreshBeginButton();
      updateStatus("Campaign started! First to 7 points.");
    }

    function setCampaignCurrentCharacter() {
      campaign.playerCharId = currentCharacter.id;
      campaign.oppCharId = charIdByName(campaignOpponent().name);
    }

    function startNewPoint() {
      campaign.ghostScore = null;
      campaign.awaitingPlayerThrow = true;

      if (campaign.pointStarter === 0) {
        campaign.ghostScore = generateGhostScore();
        showPopup(`${campaignOpponent().name}: ${campaign.ghostScore}`, { size: 58, color: "#ffffff" });
        startNewShot();
        state = State.POWER_METER;
        updateStatus("Opponent scored — your turn. Lock POWER.");
        return;
      }

      startNewShot();
      state = State.POWER_METER;
      updateStatus("You go first. Lock POWER.");
    }

    function resolveCampaignPoint(playerPts) {
      if (campaign.pointStarter === 1 && campaign.ghostScore == null) {
        campaign.ghostScore = generateGhostScore();
        showPopup(`${campaignOpponent().name}: ${campaign.ghostScore}`, { size: 58, color: "#ffffff" });
      }

      const g = campaign.ghostScore ?? 0;

      if (playerPts === g) {
        showPopup("TIE — Replay", { size: 60, color: "#ffffff" });
        campaign.ghostScore = null;
        startNewPoint();
        return;
      }

      if (playerPts > g) campaign.pScore++;
      else campaign.oScore++;

      campaign.pointStarter = 1 - campaign.pointStarter;

      const matchOver =
        (campaign.pScore >= campaign.pointsToWin) ||
        (campaign.oScore >= campaign.pointsToWin);

      if (!matchOver) {
        campaign.ghostScore = null;
        startNewPoint();
        return;
      }

      const currentOppIndex = campaign.opponentIndex;

      if (campaign.pScore >= campaign.pointsToWin) {
        if (currentOppIndex >= CAMPAIGN_OPPONENTS.length - 1) {
          campaign.lastResult = "COMPLETE";
          campaign.started = false;
          state = State.CAMPAIGN_OVER;
          updateStatus("Campaign complete!");
          return;
        }

        campaign.opponentIndex = currentOppIndex + 1;
        campaign.started = false;

        resetCampaignMatch(true);
        campaign.lastResult = "WIN";

        state = State.CAMPAIGN_OVER;
        updateStatus("You won! Advance to next opponent.");
        return;
      }

      campaign.opponentIndex = currentOppIndex;
      campaign.started = false;

      resetCampaignMatch(true);
      campaign.lastResult = "LOSE";

      state = State.CAMPAIGN_OVER;
      updateStatus("You lost. Replay this opponent.");
      return;
    }

    // -----------------------------
    // Characters (tiers) + outfits
    // -----------------------------
    const TIER_MULT = Object.freeze({ 1: 0.7, 2: 0.85, 3: 1.00, 4: 1.15, 5: 1.3 });
    const CATCH_W_MULT = Object.freeze({ 1: 0.80, 2: 0.90, 3: 1.0, 4: 1.10, 5: 1.20 });

    const CHAR_COLORS = Object.freeze({
      Brenden: "#f59e0b",
      Xavier:  "#3b82f6",
      Liam:    "#22c55e",
      Edward:  "#ef4444",
      Ethan:   "#facc15",
      Jake:    "#9ca3af",
      Hans:    "#d2b48c",
      Alex:    "#7f1d1d"
    });

    const DEFAULT_NOTE = "#111827";

    const DEFAULT_OUTFIT = {
      hair: "#3f3f46",
      face: "#fde68a",
      shirt: "#22c55e",
      pants: "#1e293b",
      outline: DEFAULT_NOTE
    };

    const CHAR_OUTFITS = Object.freeze({
      Xavier:  { hair:"#3b2f2f", face:"#fde68a", shirt:"#ffffff", pants:"#1e3a8a", outline:DEFAULT_NOTE },
      Brenden: { hair:"#f97316", face:"#fde68a", shirt:"#93c5fd", pants:"#1e3a8a", outline:DEFAULT_NOTE },
      Ethan:   { hair:"#8b5e34", face:"#fef3c7", shirt:"#22c55e", pants:"#000000", outline:DEFAULT_NOTE },
      Edward:  { hair:"#8b5e34", face:"#fee2e2", shirt:"#ef4444", pants:"#d2b48c", outline:DEFAULT_NOTE },
      Liam:    { hair:"#000000", face:"#fef3c7", shirt:"#3b82f6", pants:"#c19a6b", outline:DEFAULT_NOTE },
      Jake:    { hair:"#f7e27c", face:"#fef3c7", shirt:"#374151", pants:"#f5f5f4", outline:DEFAULT_NOTE },
      Hans:    { hair:"#000000", face:"#8d5524", shirt:"#d2b48c", pants:"#000000", outline:DEFAULT_NOTE },
      Alex:    { hair:"#c4a484", face:"#fde68a", shirt:"#7f1d1d", pants:"#6b7280", outline:DEFAULT_NOTE }
    });

    const CHARACTERS = [
      { id: 0, name: "Brenden", tiers: { control: 4, accuracy: 2, speed: 5, catching: 1 } },
      { id: 1, name: "Ethan",   tiers: { control: 5, accuracy: 5, speed: 5, catching: 5 } },
      { id: 2, name: "Xavier",  tiers: { control: 5, accuracy: 4, speed: 1, catching: 2 } },
      { id: 3, name: "Edward",  tiers: { control: 1, accuracy: 5, speed: 2, catching: 4 } },
      { id: 4, name: "Liam",    tiers: { control: 3, accuracy: 3, speed: 3, catching: 3 } },
      { id: 5, name: "Jake",    tiers: { control: 2, accuracy: 1, speed: 4, catching: 5 } },
      { id: 6, name: "Hans",    tiers: { control: 1, accuracy: 1, speed: 5, catching: 5 } },
      { id: 7, name: "Alex",    tiers: { control: 5, accuracy: 5, speed: 1, catching: 1 } }
    ].map(c => ({
      ...c,
      color: CHAR_COLORS[c.name] ?? "#d9f7d0",
      outfit: CHAR_OUTFITS[c.name] ?? DEFAULT_OUTFIT,
      stats: {
        control:  TIER_MULT[c.tiers.control],
        accuracy: TIER_MULT[c.tiers.accuracy],
        speed:    TIER_MULT[c.tiers.speed],
        catchingWidth: CATCH_W_MULT[c.tiers.catching]
      }
    }));

    let currentCharacter = CHARACTERS[0];

    function tiersTextFor(charObj) {
      const t = charObj?.tiers;
      if (!t) return "";
      return `C${t.control} A${t.accuracy} S${t.speed} H${t.catching}`;
    }

    function updateCharacterButtons() {
      const activeCharId = match.enabled
        ? (match.started ? match.players[match.activeIndex].characterId : match.players[match.setupPickIndex].characterId)
        : currentCharacter.id;

      for (let i = 0; i < CHARACTERS.length; i++) {
        const btn = document.getElementById("ch" + i);
        if (!btn) continue;
        btn.classList.toggle("active", i === activeCharId);
      }
    }

    function setCurrentCharacterForTurn() {
      if (!match.enabled) return;
      const cid = match.players[match.activeIndex].characterId;
      currentCharacter = CHARACTERS[cid ?? 0];
      updateCharacterButtons();
    }

    function applyCharacter(charIndex) {
      if (match.enabled && match.started) return;
      if (campaign.enabled && campaign.started) return;

      if (match.enabled) {
        match.players[match.setupPickIndex].characterId = charIndex;
        const cid = match.players[match.setupPickIndex].characterId;
        currentCharacter = CHARACTERS[cid ?? 0];

        updateCharacterButtons();
        updateStatus(`Assigned ${currentCharacter.name} to P${match.setupPickIndex + 1}`);
        refreshBeginButton();
      } else {
        currentCharacter = CHARACTERS[charIndex];
        updateCharacterButtons();
        if (campaign.enabled) {
          setCampaignCurrentCharacter();
          updateStatus(`Campaign: You = ${currentCharacter.name} vs ${campaignOpponent().name}`);
        } else {
          updateStatus(`Character: ${currentCharacter.name}`);
        }
        refreshBeginButton();
      }
    }

    for (let i = 0; i < 8; i++) {
      const el = document.getElementById("ch" + i);
      if (el) el.onclick = () => applyCharacter(i);
    }

    // -----------------------------
    // Level selection
    // -----------------------------
    function applyLevel(levelIndex) {
      if (match.enabled && match.started) return;
      if (campaign.enabled && campaign.started) return;

      const L = LEVELS[levelIndex];
      arena.level = L;
      arena.theme = L.theme || THEMES.townhouse;

      arena.roofType = L.roofType;
      arena.gravity = L.gravity;
      arena.restitutionFloor = L.restitutionFloor;
      arena.restitutionWall = L.restitutionWall;
      arena.restitutionRoof = L.restitutionRoof;

      if (L.roofType === "flat") {
        arena.roofY = L.roofY;
      } else if (L.roofType === "angled") {
        arena.roofLeftY = L.roofLeftY;
        arena.roofRightY = L.roofRightY;
      }

      if (L.id === 0) {
        arena.wallTopY = clamp(roofAtX(wallX), 0, floorY - 40);
      } else if (L.id === 1) {
        arena.wallTopY = 0;
      } else {
        arena.wallTopY = clamp(L.wallTopY, 0, floorY - 40);
      }

      for (let i = 0; i < 4; i++) {
        const b = document.getElementById("btn" + i);
        if (b) b.classList.toggle("active", i === levelIndex);
      }

      startNewShot();
      state = State.POWER_METER;
      updateStatus(`Selected: ${L.name}. Lock POWER.`);
      refreshBeginButton();
    }

    document.getElementById("btn0").onclick = () => applyLevel(0);
    document.getElementById("btn1").onclick = () => applyLevel(1);
    document.getElementById("btn2").onclick = () => applyLevel(2);
    document.getElementById("btn3").onclick = () => applyLevel(3);

    // -----------------------------
    // Mode switching + Begin button logic
    // -----------------------------
    function canBeginGame() {
      const okLevel = !!arena.level;

      if (match.enabled) {
        const okChars = match.players[0].characterId != null && match.players[1].characterId != null;
        return okLevel && okChars && !match.started;
      }

      if (campaign.enabled) {
        return okLevel && !campaign.started && state !== State.CAMPAIGN_OVER;
      }

      return false;
    }

    function refreshBeginButton() {
      beginBtn.disabled = !canBeginGame();
      beginBtn.classList.toggle("active", canBeginGame());

      if (match.enabled) beginBtn.textContent = "Begin Match";
      else if (campaign.enabled) beginBtn.textContent = "Begin Match";
      else beginBtn.textContent = "Begin";
    }

    function beginGame() {
      if (match.enabled) return beginHotseat();
      if (campaign.enabled) return beginCampaignMatch();
    }
    beginBtn.onclick = beginGame;

    function beginHotseat() {
      if (!canBeginGame()) return;

      match.started = true;

      match.roundNum = 1;
      match.roundStarter = 0;
      match.activeIndex = match.roundStarter;
      match.winnerIndex = null;
      match.roundShots = [null, null];
      match.firstPlayerScoredZeroThisRound = false;

      match.players[0].roundsWon = 0; match.players[1].roundsWon = 0;
      resetPlayerStats(match.players[0]);
      resetPlayerStats(match.players[1]);

      setCurrentCharacterForTurn();
      startNewShot();
      state = State.POWER_METER;
      updateStatus("Game started! P1 lock POWER.");
      refreshBeginButton();
    }

    function setMode(mode) {
      gameMode = mode;

      match.enabled = (mode === Mode.MULTI);
      campaign.enabled = (mode === Mode.CAMPAIGN);

      match.started = false;
      campaign.started = false;

      document.getElementById("modeSingle").classList.toggle("active", mode === Mode.SINGLE);
      document.getElementById("modeMulti").classList.toggle("active", mode === Mode.MULTI);
      document.getElementById("modeCampaign").classList.toggle("active", mode === Mode.CAMPAIGN);

      match.roundNum = 1;
      match.roundStarter = 0;
      match.activeIndex = 0;
      match.winnerIndex = null;
      match.roundShots = [null, null];
      match.setupPickIndex = 0;
      match.firstPlayerScoredZeroThisRound = false;
      match.players[0].roundsWon = 0; match.players[1].roundsWon = 0;

      resetSingleStats();
      resetPlayerStats(match.players[0]);
      resetPlayerStats(match.players[1]);

      if (mode === Mode.MULTI) {
        if (match.players[0].characterId == null) match.players[0].characterId = 0;
        if (match.players[1].characterId == null) match.players[1].characterId = 1;
        currentCharacter = CHARACTERS[match.players[0].characterId] ?? CHARACTERS[0];
      } else {
        currentCharacter = currentCharacter ?? CHARACTERS[0];
      }

      if (mode === Mode.CAMPAIGN) {
        resetCampaignMatch(true);
        setCampaignCurrentCharacter();
      }

      updateCharacterButtons();
      resetGame();
      refreshBeginButton();

      if (mode === Mode.MULTI) updateStatus("2P Hotseat: pick a level, assign chars to P1/P2, then Begin Game.");
      else if (mode === Mode.CAMPAIGN) updateStatus(`Campaign: pick a level + your character, then Begin (Opponent: ${campaignOpponent().name})`);
      else updateStatus("Single Player: pick a level.");
    }

    document.getElementById("modeSingle").onclick   = () => setMode(Mode.SINGLE);
    document.getElementById("modeMulti").onclick    = () => setMode(Mode.MULTI);
    document.getElementById("modeCampaign").onclick = () => setMode(Mode.CAMPAIGN);

    // -----------------------------
    // Player + Glove + Jump (↑)
    // -----------------------------
    const player = { x: playLeft + 20, y: 0, w: 80, h: 110, baseSpeed: 720, vy: 0 };

    function groundY() { return floorY - player.h; }
    function isPlayerGrounded() { return player.y >= groundY() - 0.5 && Math.abs(player.vy) < 0.01; }
    function jumpImpulse() { const jumpH = player.h * 0.9; return Math.sqrt(2 * arena.gravity * jumpH); }

    function attemptJump() {
      if (state === State.TITLE || state === State.MATCH_OVER || state === State.SINGLE_OVER || state === State.CAMPAIGN_OVER) return;
      if (!arena.level) return;
      if (match.enabled && !match.started) return;
      if (campaign.enabled && !campaign.started) return;
      if (isPlayerGrounded()) player.vy = -jumpImpulse();
    }

    function getHandsRect() {
      let hw = Math.round(player.w * 0.55);
      let hh = Math.round(player.h * 0.22);

      const catchMul = currentCharacter?.stats?.catchingWidth ?? 1;
      hw = Math.round(hw * catchMul);

      const offsetX = Math.round(player.w * 0.10);
      const hx = player.x + player.w + offsetX;
      const hy = player.y + Math.round(player.h * 0.35);

      return { x: hx, y: hy, w: hw, h: hh };
    }

    // -----------------------------
    // Ball (with spin)
    // -----------------------------
    const ball = { r: 12, x: 0, y: 0, vx: 0, vy: 0, active: false, spin: 0, spinV: 0 };

    // -----------------------------
    // Screen shake (on 100)
    // -----------------------------
    let screenShake = 0;
    let screenShakeMag = 0;

    // -----------------------------
    // State machine
    // -----------------------------
    const State = Object.freeze({
      TITLE: "TITLE",
      SELECT_LEVEL: "SELECT_LEVEL",
      POWER_METER: "POWER_METER",
      ANGLE_METER: "ANGLE_METER",
      FLIGHT: "FLIGHT",
      RETURNING: "RETURNING",
      MATCH_OVER: "MATCH_OVER",
      SINGLE_OVER: "SINGLE_OVER",
      CAMPAIGN_OVER: "CAMPAIGN_OVER"
    });
    let state = State.TITLE;

    // -----------------------------
    // Timing meter
    // -----------------------------
    const meter = {
      value: 0.0,
      dir: 1,
      basePowerSpeed: 1.35,
      baseAngleSpeed: 1.35,
      lockedPower: null,
      lockedAngleRad: null
    };

    function effectivePowerSpeed() { const c = currentCharacter?.stats?.control ?? 1; return meter.basePowerSpeed / c; }
    function effectiveAngleSpeed() { const a = currentCharacter?.stats?.accuracy ?? 1; return meter.baseAngleSpeed / a; }

    // -----------------------------
    // Shot context
    // -----------------------------
    function newShotContext() {
      return {
        bouncedBeforeWall: false,
        hitWall: false,
        hitRoofBeforeWall: false,
        wallHitY: null,
        pendingPoints: 0,
        invalid: false,
        invalidReason: "",
        popupCeilingShown: false
      };
    }
    let shot = newShotContext();

    // -----------------------------
    // Stats (Single + Multiplayer)
    // -----------------------------
    let lastThrowPoints = null;
    let lastWallHitY = null;

    const singleStats = { throws: 0, sum: 0, walmart100s: 0, layups: 0, attempts: 0, catches: 0, best: null };

    function resetSingleStats() {
      singleStats.throws = 0;
      singleStats.sum = 0;
      singleStats.walmart100s = 0;
      singleStats.layups = 0;
      singleStats.attempts = 0;
      singleStats.catches = 0;
      singleStats.best = null;
    }

    function avgScore(stats) { return stats.throws > 0 ? (stats.sum / stats.throws) : 0; }
    function catchPct(stats) { return stats.attempts > 0 ? (stats.catches / stats.attempts) : 0; }

    // -----------------------------
    // Scoring helper
    // -----------------------------
    function scoreFromWallHit(yHit) {
      const top = arena.wallTopY + ball.r;
      const bottom = floorY - ball.r;

      const clampedY = clamp(yHit, top, bottom);
      const height = bottom - clampedY;
      const maxHeight = bottom - top;

      const raw = 1 + (99 * (height / maxHeight));
      return clamp(Math.round(raw), 1, 100);
    }

    function updateStatus(extra = "") {
      const lvl = arena.level ? ` | Level: ${arena.level.name}` : "";

      if (match.enabled) {
        const turn = match.started ? ` | Turn: P${match.activeIndex + 1}` : ` | Setup: click P1/P2 in panel`;
        statusEl.textContent = `2P Hotseat (to ${match.roundsToWin}) | Round ${match.roundNum}${lvl}${turn}${extra ? " — " + extra : ""}`;
        return;
      }

      if (campaign.enabled) {
        const opp = campaignOpponent();
        const starter = campaign.pointStarter === 0 ? "Opponent first" : "You first";
        const beginHint = campaign.started ? "" : " (press Begin)";
        statusEl.textContent =
          `CAMPAIGN${beginHint} | Opponent: ${opp.name} (#${campaign.opponentIndex + 1}/8) | Score ${campaign.pScore}-${campaign.oScore} | ${starter}` +
          `${lvl}${extra ? " — " + extra : ""}`;
        return;
      }

      const last = (lastThrowPoints == null) ? "" : ` | Last: ${lastThrowPoints}`;
      const inv = shot?.invalid ? ` | INVALID: ${shot.invalidReason}` : "";
      const ch = currentCharacter ? ` | Char: ${currentCharacter.name} (${tiersTextFor(currentCharacter)})` : "";

      const avg = avgScore(singleStats);
      const best = singleStats.best ?? "-";
      const pct = Math.round(catchPct(singleStats) * 100);
      const w100 = singleStats.walmart100s;

      statusEl.textContent =
        `Avg: ${avg.toFixed(1)} | Best: ${best} | Catch%: ${pct}% | Walmart100s: ${w100}` +
        `${last}${inv}${lvl}${ch}${extra ? " — " + extra : ""}`;
    }

    // -----------------------------
    // Helper: end the run (Single Over)
    // -----------------------------
    function endSingleRun() {
      state = State.SINGLE_OVER;
      singleShotTimer = 0;
      updateStatus("RUN OVER");
    }
    function singleRunIsOver() { return singleStats.attempts >= SINGLE_TURNS && singleStats.throws >= SINGLE_TURNS; }

    // -----------------------------
    // Input
    // -----------------------------
    const keys = {};
    window.addEventListener("keydown", (e) => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key) || e.code === "Space") e.preventDefault();

      const wasDown = !!keys[e.key];
      keys[e.key] = true;

      if (e.key.toLowerCase() === "r") resetGame();
      if (e.key === " " || e.code === "Space") handleAction();
      if (!wasDown && e.key === "ArrowUp") attemptJump();
    }, { passive: false });

    window.addEventListener("keyup", (e) => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key) || e.code === "Space") e.preventDefault();
      keys[e.key] = false;
    }, { passive: false });

    canvas.addEventListener("mousedown", () => handleAction());

    // -----------------------------
    // Touch controls (mobile)
    // -----------------------------
    const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

    function setupTouchButton(id, onDown, onUp) {
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener("touchstart", (e) => {
        e.preventDefault();
        el.classList.add("pressed");
        onDown();
      }, { passive: false });
      el.addEventListener("touchend", (e) => {
        e.preventDefault();
        el.classList.remove("pressed");
        if (onUp) onUp();
      }, { passive: false });
      el.addEventListener("touchcancel", (e) => {
        e.preventDefault();
        el.classList.remove("pressed");
        if (onUp) onUp();
      }, { passive: false });
    }

    setupTouchButton("tc-left",
      () => { keys["ArrowLeft"] = true; },
      () => { keys["ArrowLeft"] = false; }
    );
    setupTouchButton("tc-right",
      () => { keys["ArrowRight"] = true; },
      () => { keys["ArrowRight"] = false; }
    );
    setupTouchButton("tc-jump",
      () => { attemptJump(); },
      null
    );
    setupTouchButton("tc-action",
      () => { handleAction(); },
      null
    );
    setupTouchButton("tc-reset",
      () => { resetGame(); },
      null
    );

    // Canvas tap = action on touch devices
    canvas.addEventListener("touchstart", (e) => {
      // Only trigger action if the touch is in the gameplay area (not on controls)
      const rect = canvas.getBoundingClientRect();
      const tx = (e.touches[0].clientX - rect.left) * (canvas.width / rect.width);
      const ty = (e.touches[0].clientY - rect.top) * (canvas.height / rect.height);

      // Check for panel hit test in multiplayer setup
      const hit = panelHitTestPlayerBlocks(tx, ty);
      if (hit != null) {
        match.setupPickIndex = hit;
        const cid = match.players[hit].characterId ?? 0;
        currentCharacter = CHARACTERS[cid] ?? CHARACTERS[0];
        updateCharacterButtons();
        updateStatus(`Assigning for P${hit + 1} (click character buttons)`);
        refreshBeginButton();
        e.preventDefault();
        return;
      }

      handleAction();
      e.preventDefault();
    }, { passive: false });

    // Prevent default touch behaviors on canvas
    canvas.addEventListener("touchmove", (e) => { e.preventDefault(); }, { passive: false });

    // -----------------------------
    // Concrete texture helper (Berlin)
    // -----------------------------
    function drawConcreteTexture(x, y, w, h) {
      ctx.strokeStyle = "rgba(0,0,0,0.08)";
      ctx.lineWidth = 1;
      for (let i = 0; i < 120; i++) {
        const px = x + Math.random() * w;
        const py = y + Math.random() * h;
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px + Math.random() * 6, py + Math.random() * 6);
        ctx.stroke();
      }
    }

    // -----------------------------
    // NEW: Moon background props (STATIC earth + 4 stars)
    // -----------------------------
    const MOON_STARS = Object.freeze([
      { x: playLeft + 160, y: 130, r: 3.5, a: 0.85 },
      { x: playLeft + 520, y: 90,  r: 2.8, a: 0.80 },
      { x: playLeft + 860, y: 160, r: 3.2, a: 0.78 },
      { x: playLeft + 1120, y: 110, r: 2.6, a: 0.82 }
    ]);

    function drawMoonBackgroundProps() {
      if (!arena.level || arena.level.id !== 1) return;

      ctx.save();

      // clip to playable AIR space only
      ctx.beginPath();
      ctx.rect(playLeft, 0, wallX - playLeft, floorY);
      ctx.clip();

      // Stars (4, whitish)
      for (const s of MOON_STARS) {
        ctx.globalAlpha = s.a;
        ctx.fillStyle = "rgba(245, 245, 255, 1)";
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();

        // tiny cross sparkle
        ctx.globalAlpha = s.a * 0.6;
        ctx.strokeStyle = "rgba(245,245,255,1)";
        ctx.lineWidth = 1.6;
        ctx.beginPath();
        ctx.moveTo(s.x - s.r * 2.2, s.y);
        ctx.lineTo(s.x + s.r * 2.2, s.y);
        ctx.moveTo(s.x, s.y - s.r * 2.2);
        ctx.lineTo(s.x, s.y + s.r * 2.2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Earth (static planet)
      const ex = playLeft + 200;
      const ey = 150;
      const er = 120;

      // soft glow
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "rgba(59,130,246,0.35)";
      ctx.beginPath();
      ctx.arc(ex, ey, er + 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // planet body gradient
      const g = ctx.createRadialGradient(ex - er * 0.35, ey - er * 0.35, er * 0.25, ex, ey, er);
      g.addColorStop(0, "rgba(192,132,252,1)");
      g.addColorStop(1, "rgba(88,28,135,1)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(ex, ey, er, 0, Math.PI * 2);
      ctx.fill();

      // land blobs (simple stylized)
      ctx.fillStyle = "rgba(192,132,252,1)";
      ctx.beginPath();
      ctx.ellipse(ex - 18, ey - 10, 22, 14, 0.2, 0, Math.PI * 2);
      ctx.ellipse(ex + 20, ey + 8, 26, 16, -0.3, 0, Math.PI * 2);
      ctx.ellipse(ex + 8, ey - 26, 16, 10, 0.5, 0, Math.PI * 2);
      ctx.fill();

      // clouds
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(255,255,255,1)";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.arc(ex, ey, er * 0.72, -0.2, 1.0);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(ex, ey, er * 0.55, 1.5, 2.5);
      ctx.stroke();
      ctx.globalAlpha = 1;

      // subtle rim light
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(ex, ey, er, -0.9, 0.4);
      ctx.stroke();

      ctx.restore();
    }

    // -----------------------------
    // Berlin background props (moved OUTSIDE draw)
    // -----------------------------
    function drawBerlinBackgroundProps() {
      if (!arena.level || arena.level.id !== 2) return;

      ctx.save();
      ctx.beginPath();
      ctx.rect(playLeft, 0, wallX - playLeft, floorY);
      ctx.clip();

      // CAR
      const carX = playLeft + 170;
      const carBaseY = floorY;
      const carW = 340;
      const carH = 80;

      ctx.fillStyle = "rgba(17,24,39,0.30)";
      ctx.fillRect(carX, carBaseY - carH, carW, carH);

      ctx.fillStyle = "rgba(17,24,39,0.22)";
      ctx.beginPath();
      ctx.moveTo(carX + 70,  carBaseY - carH);
      ctx.lineTo(carX + 120, carBaseY - carH - 50);
      ctx.lineTo(carX + 230, carBaseY - carH - 50);
      ctx.lineTo(carX + 280, carBaseY - carH);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "rgba(186,230,253,0.35)";
      ctx.fillRect(carX + 135, carBaseY - carH - 45, 85, 30);

      ctx.fillStyle = "rgba(0,0,0,0.35)";
      const wheelR = 20;
      ctx.beginPath();
      ctx.arc(carX + 85,  carBaseY - 5, wheelR, 0, Math.PI * 2);
      ctx.arc(carX + 255, carBaseY - 5, wheelR, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.lineWidth = 3;
      ctx.strokeRect(carX, carBaseY - carH, carW, carH);

      // STREET LAMP
      const lampX = carX + carW + 170;
      const lampBaseY = floorY;
      const lampHeight = 280;
      const lampTopY = lampBaseY - lampHeight;

      ctx.strokeStyle = "rgba(17,24,39,0.35)";
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(lampX, lampTopY);
      ctx.lineTo(lampX, lampBaseY);
      ctx.stroke();

      ctx.lineWidth = 7;
      ctx.beginPath();
      ctx.moveTo(lampX, lampTopY + 20);
      ctx.lineTo(lampX + 70, lampTopY + 20);
      ctx.stroke();

      ctx.fillStyle = "rgba(17,24,39,0.30)";
      ctx.fillRect(lampX + 60, lampTopY + 8, 34, 24);

      ctx.fillStyle = "rgba(250,204,21,0.06)";
      ctx.beginPath();
      ctx.moveTo(lampX + 77, lampTopY + 32);
      ctx.lineTo(lampX + 165, lampBaseY);
      ctx.lineTo(lampX - 10,  lampBaseY);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

function drawSquashBackgroundProps() {
  if (!arena.level || arena.level.id !== 3) return; // Squash = id 3

  ctx.save();

  // Clip to playable AIR only (prevents drawing over floor/wall blocks)
  ctx.beginPath();
  ctx.rect(playLeft, 0, wallX - playLeft, floorY);
  ctx.clip();

  const roofY = roofAtX(playLeft + 60); // squash roof is flat anyway
  const cx = playLeft + (wallX - playLeft) * 0.5;

  // -----------------------
  // TWO CEILING-MOUNTED LIGHTS
  // -----------------------
  function drawCeilingLight(x) {
    const mountY = roofY + 14;     // how "attached" to the roof it looks
    const bodyW = 140;
    const bodyH = 22;

    // mount stem
    ctx.strokeStyle = "rgba(15,23,42,0.35)";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(x, roofY + 2);
    ctx.lineTo(x, mountY);
    ctx.stroke();

    // light body
    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.fillRect(x - bodyW/2, mountY, bodyW, bodyH);

    // body outline
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.lineWidth = 3;
    ctx.strokeRect(x - bodyW/2, mountY, bodyW, bodyH);

    // glow cone (subtle)
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.beginPath();
    ctx.moveTo(x - bodyW/2, mountY + bodyH);
    ctx.lineTo(x + bodyW/2, mountY + bodyH);
    ctx.lineTo(x + 240, floorY - 10);
    ctx.lineTo(x - 240, floorY - 10);
    ctx.closePath();
    ctx.fill();
  }

  // positions (edit these to move the lights)
  const light1X = playLeft + (wallX - playLeft) * 0.33;
  const light2X = playLeft + (wallX - playLeft) * 0.70;

  drawCeilingLight(light1X);
  drawCeilingLight(light2X);

  // -----------------------
  // SCOREBOARD (on back wall area)
  // -----------------------
  const sbW = 260;
  const sbH = 110;

  // position (edit these to move scoreboard)
  const sbX = cx - sbW / 2;
  const sbY = roofY + 120;

  // board frame
  ctx.fillStyle = "rgba(15,23,42,0.35)";
  ctx.fillRect(sbX, sbY, sbW, sbH);

  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = 3;
  ctx.strokeRect(sbX, sbY, sbW, sbH);

  // inner screen
  ctx.fillStyle = "rgba(0,0,0,0.45)";
  ctx.fillRect(sbX + 10, sbY + 10, sbW - 20, sbH - 20);

  // text
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.textAlign = "center";
  ctx.font = "16px system-ui";
  ctx.fillText("SQUASH", sbX + sbW/2, sbY + 32);

  ctx.font = "28px system-ui";
  ctx.fillText("0  -  0", sbX + sbW/2, sbY + 72);

  ctx.font = "12px system-ui";
  ctx.fillStyle = "rgba(255,255,255,0.55)";
  ctx.fillText("BIG BOUNCE COURT", sbX + sbW/2, sbY + 98);

  ctx.textAlign = "left";
  ctx.restore();
}


    // -----------------------------
    // Townhouse props (as you had)
    // -----------------------------
    function drawTownhouseBackgroundProps() {
      if (!arena.level || arena.level.id !== 0) return;

      ctx.save();

      ctx.beginPath();
      ctx.rect(playLeft, 0, wallX - playLeft, floorY);
      ctx.clip();

      // WINDOW
      const wx = playLeft + 700;
      const wy = 450;
      const ww = 220;
      const wh = 170;

      ctx.fillStyle = "#bae6fd";
      ctx.fillRect(wx, wy, ww, wh);

      ctx.strokeStyle = "rgba(15,23,42,0.35)";
      ctx.lineWidth = 4;
      ctx.strokeRect(wx, wy, ww, wh);

      ctx.strokeStyle = "rgba(15,23,42,0.25)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(wx + ww / 2, wy);
      ctx.lineTo(wx + ww / 2, wy + wh);
      ctx.moveTo(wx, wy + wh / 2);
      ctx.lineTo(wx + ww, wy + wh / 2);
      ctx.stroke();

      // LAMP
      const lx = playLeft + 150;
      const lampBaseY = floorY;
      const lampHeight = 240;
      const ly = lampBaseY - lampHeight;

      ctx.strokeStyle = "rgba(15,23,42,0.35)";
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(lx, ly + 40);
      ctx.lineTo(lx, lampBaseY);
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.beginPath();
      ctx.moveTo(lx - 55, ly + 40);
      ctx.lineTo(lx + 55, ly + 40);
      ctx.lineTo(lx + 35, ly - 25);
      ctx.lineTo(lx - 35, ly - 25);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "rgba(15,23,42,0.25)";
      ctx.lineWidth = 3;
      ctx.stroke();

      // GREEN COUCH
      const cx = playLeft + 250;
      const cy = floorY - 90;
      const cw = 380;
      const ch = 95;

      ctx.fillStyle = "#16a34a";
      ctx.fillRect(cx, cy, cw, ch);

      ctx.fillStyle = "#15803d";
      ctx.fillRect(cx, cy - 70, cw, 75);

      ctx.fillStyle = "#166534";
      ctx.fillRect(cx - 28, cy - 50, 35, ch + 50);
      ctx.fillRect(cx + cw - 7, cy - 50, 35, ch + 50);

      ctx.strokeStyle = "rgba(15,23,42,0.35)";
      ctx.lineWidth = 4;
      ctx.strokeRect(cx, cy - 70, cw, ch + 70);
      ctx.strokeRect(cx - 28, cy - 50, 35, ch + 50);
      ctx.strokeRect(cx + cw - 7, cy - 50, 35, ch + 50);

      ctx.restore();
    }

    // -----------------------------
    // Helpers
    // -----------------------------
    function rectsOverlap(a, b) {
      return a.x < b.x + b.w && a.x + a.w > b.x &&
             a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function resetBallToHand() {
      const hands = getHandsRect();
      ball.active = false;
      ball.vx = 0;
      ball.vy = 0;
      ball.x = hands.x + hands.w * 0.35;
      ball.y = hands.y + hands.h * 0.55;
    }

    function resetMeters() {
      meter.value = 0.0;
      meter.dir = 1;
      meter.lockedPower = null;
      meter.lockedAngleRad = null;
    }

    function startNewShot() {
      shot = newShotContext();
      resetMeters();
      resetBallToHand();
      singleShotTimer = 0;
      state = arena.level ? State.POWER_METER : State.SELECT_LEVEL;
      updateStatus(arena.level ? "Ready: lock POWER." : "Select a level to begin.");
    }

    function resetGame() {
      lastThrowPoints = null;
      lastWallHitY = null;

      resetSingleStats();
      resetPlayerStats(match.players[0]);
      resetPlayerStats(match.players[1]);

      match.winnerIndex = null;
      match.roundNum = 1;
      match.roundStarter = 0;
      match.activeIndex = 0;
      match.roundShots = [null, null];
      match.firstPlayerScoredZeroThisRound = false;

      match.players[0].roundsWon = 0; match.players[1].roundsWon = 0;
      if (match.enabled) match.started = false;

      if (campaign.enabled) {
        campaign.started = false;
        resetCampaignMatch(true);
      }

      player.x = playLeft + 20;
      player.y = groundY();
      player.vy = 0;

      if (match.enabled) {
        match.setupPickIndex = 0;
        currentCharacter = CHARACTERS[match.players[0].characterId ?? 0];
      }

      startNewShot();
      refreshBeginButton();

      if (match.enabled) updateStatus("2P reset. Pick a level, assign chars, Begin Game.");
      else if (campaign.enabled) updateStatus(`Campaign reset. Opponent: ${campaignOpponent().name}. Pick level + character, Begin.`);
      else updateStatus("Reset. Select a level.");
    }

    // -----------------------------
    // Meter logic
    // -----------------------------
    function meterStep(dt, speed) {
      meter.value += meter.dir * speed * dt;
      if (meter.value >= 1) { meter.value = 1; meter.dir = -1; }
      if (meter.value <= 0) { meter.value = 0; meter.dir = 1; }
    }

    // -----------------------------
    // Actions
    // -----------------------------
    function startFromTitle() {
      state = State.SELECT_LEVEL;
      updateStatus(match.enabled ? "Pick a level, assign chars, then Begin Game."
                 : campaign.enabled ? "Campaign: pick a level + character, then Begin."
                 : "Pick a level to begin.");
      refreshBeginButton();
    }

    function handleAction() {
      if (state === State.TITLE) { startFromTitle(); return; }

      if (state === State.MATCH_OVER) return;
      if (state === State.SELECT_LEVEL) return;
      if (!arena.level) return;

      if (state === State.SINGLE_OVER) return;
      if (state === State.CAMPAIGN_OVER) return;

      if (!match.enabled && !campaign.enabled && singleStats.attempts >= SINGLE_TURNS) {
        endSingleRun();
        return;
      }

      if (match.enabled && !match.started) return;
      if (campaign.enabled && !campaign.started) return;

      if (state === State.POWER_METER) {
        meter.lockedPower = meter.value;
        state = State.ANGLE_METER;

        meter.value = 0.5;
        meter.dir = (Math.random() < 0.5) ? -1 : 1;

        updateStatus("Power locked. Lock ANGLE.");
        return;
      }

      if (state === State.ANGLE_METER) {
        const minDeg = -90;
        const maxDeg = -60;
        const deg = minDeg + (maxDeg - minDeg) * meter.value;
        meter.lockedAngleRad = (deg * Math.PI) / 180;
        launchBall();
        return;
      }
    }

    function launchBall() {
      const p = meter.lockedPower ?? 0.5;

      const minSpeed = 950;
      const maxSpeed = 2200;
      const speed = minSpeed + (maxSpeed - minSpeed) * p;

      const a = meter.lockedAngleRad ?? (-75 * Math.PI / 180);

      resetBallToHand();
      ball.active = true;

      if (match.enabled) match.players[match.activeIndex].attempts++;
      else if (!campaign.enabled) singleStats.attempts++;

      if (!match.enabled && !campaign.enabled) singleShotTimer = SINGLE_SHOT_TIMEOUT_S;

      const vxRaw = Math.cos(a) * speed;
      ball.vx = Math.max(160, vxRaw);
      ball.vy = -Math.sin(a) * speed;

      ball.spin = 0;
      ball.spinV = (ball.vx >= 0 ? 1 : -1) * (6 + 10 * (meter.lockedPower ?? 0.5));

      shot = newShotContext();
      state = State.FLIGHT;
      updateStatus("Ball in flight.");
    }

    // -----------------------------
    // Update loops
    // -----------------------------
    function updatePlayer(dt) {
      const left = keys["ArrowLeft"];
      const right = keys["ArrowRight"];

      const speedMul = currentCharacter?.stats?.speed ?? 1;
      const effectiveSpeed = player.baseSpeed * speedMul;

      if (left) player.x -= effectiveSpeed * dt;
      if (right) player.x += effectiveSpeed * dt;

      player.x = clamp(player.x, playLeft, wallX - player.w - 10);

      player.vy += arena.gravity * dt;
      player.y += player.vy * dt;

      const gy = groundY();
      if (player.y > gy) { player.y = gy; player.vy = 0; }

      const hands = getHandsRect();
      const overflow = (hands.x + hands.w) - (wallX - 6);
      if (overflow > 0) {
        player.x -= overflow;
        player.x = clamp(player.x, playLeft, wallX - player.w - 10);
      }
    }

    function markInvalid(reason) {
      if (!shot.invalid) {
        shot.invalid = true;
        shot.invalidReason = reason;
        shot.pendingPoints = 0;
      }
    }

    function updateBall(dt) {
      if (!ball.active) return;

      ball.vy += arena.gravity * dt;
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      ball.spin += ball.spinV * dt;
      ball.spinV *= 0.995;

      ball.vx *= arena.airDrag;
      ball.vy *= arena.airDrag;

      if (arena.roofType !== "none") {
        const ry = roofAtX(ball.x);

        if (ball.y - ball.r <= ry && ball.vy < 0) {
          let nx = 0, ny = 1;

          if (arena.roofType === "angled") {
            const y0 = roofAtX(playLeft);
            const y1 = roofAtX(wallX);

            const dx = (wallX - playLeft);
            const dy = (y1 - y0);

            let n1x = -dy, n1y = dx;
            let n2x = dy,  n2y = -dx;

            const len1 = Math.hypot(n1x, n1y) || 1;
            n1x /= len1; n1y /= len1;

            const len2 = Math.hypot(n2x, n2y) || 1;
            n2x /= len2; n2y /= len2;

            if (n1y > 0) { nx = n1x; ny = n1y; }
            else         { nx = n2x; ny = n2y; }
          }

          const EPS = 0.6;
          ball.y = ry + ball.r + EPS * ny;
          ball.x = ball.x + EPS * nx;

          const e = arena.restitutionRoof;
          const vDotN = ball.vx * nx + ball.vy * ny;

          if (vDotN < 0) {
            ball.vx = ball.vx - (1 + e) * vDotN * nx;
            ball.vy = ball.vy - (1 + e) * vDotN * ny;
          }

          if (!shot.hitWall) {
            shot.hitRoofBeforeWall = true;
            markInvalid("Roof hit before wall");

            if (!shot.popupCeilingShown) {
              shot.popupCeilingShown = true;
              showPopup("Ceiling Fault", { size: 64, color: "#ffffff" });
            }
          }
        }
      }

      if (ball.y + ball.r >= floorY) {
        ball.y = floorY - ball.r;
        ball.vy = -ball.vy * arena.restitutionFloor;
        ball.vx *= arena.floorFriction;

        if (!shot.hitWall) shot.bouncedBeforeWall = true;
      }

      if (ball.x + ball.r >= wallX) {
        const withinWallFace = (ball.y + ball.r >= arena.wallTopY) && (ball.y - ball.r <= floorY);

        if (!withinWallFace) {
          if (!shot.hitWall) {
            markInvalid("Missed wall face");
            state = State.RETURNING;
            updateStatus("Missed wall face — still catch to finish.");
          }
          ball.x = wallX - ball.r;
          ball.vx = -Math.abs(ball.vx) * arena.restitutionWall;
        } else {
          ball.x = wallX - ball.r;

          if (!shot.hitWall) {
            shot.hitWall = true;
            shot.wallHitY = ball.y;
            lastWallHitY = ball.y;

            if (!shot.bouncedBeforeWall) markInvalid("No bounce before wall");
            if (!shot.invalid) shot.pendingPoints = scoreFromWallHit(ball.y);

            state = State.RETURNING;
            updateStatus("Wall hit — catch it!");
          }

          ball.vx = -Math.abs(ball.vx) * arena.restitutionWall;
        }
      }

      if (ball.x - ball.r < playLeft) {
        ball.x = playLeft + ball.r;
        ball.vx = Math.abs(ball.vx) * 0.6;
      }
    }

    // -----------------------------
    // Multiplayer turn/round resolution
    // -----------------------------
    function endTurnWithPoints(pts) {
      const ai = match.activeIndex;
      const oi = 1 - ai;

      const p = match.players[ai];
      p.lastThrow = pts;

      p.throws++;
      p.sum += pts;
      p.best = (p.best == null) ? pts : Math.max(p.best, pts);
      if (pts === 100) p.walmart100s++;

      match.roundShots[ai] = pts;

      if (ai === match.roundStarter && pts === 0 && match.roundShots[oi] == null) {
        match.firstPlayerScoredZeroThisRound = true;
        showPopup("Layup Chance", { size: 64, color: "#ffffff" });
      }

      if (match.roundShots[oi] == null) {
        match.activeIndex = oi;
        setCurrentCharacterForTurn();
        startNewShot();
        updateStatus(`P${match.activeIndex + 1} turn`);
        return;
      }

      const p1 = match.roundShots[0];
      const p2 = match.roundShots[1];

      const first = match.roundStarter;
      const second = 1 - first;
      const firstPts = match.roundShots[first];
      const secondPts = match.roundShots[second];

      if (match.firstPlayerScoredZeroThisRound && firstPts === 0 && secondPts > firstPts) {
        match.players[second].layups++;
        showPopup("Layup", { size: 74, color: "#ffffff" });
      }

      if (p1 > p2) match.players[0].roundsWon++;
      else if (p2 > p1) match.players[1].roundsWon++;

      if (match.players[0].roundsWon >= match.roundsToWin) {
        match.winnerIndex = 0;
        state = State.MATCH_OVER;
        updateStatus("Match over!");
        return;
      }
      if (match.players[1].roundsWon >= match.roundsToWin) {
        match.winnerIndex = 1;
        state = State.MATCH_OVER;
        updateStatus("Match over!");
        return;
      }

      match.roundNum++;
      match.roundShots = [null, null];
      match.roundStarter = 1 - match.roundStarter;
      match.activeIndex = match.roundStarter;
      match.firstPlayerScoredZeroThisRound = false;

      setCurrentCharacterForTurn();
      startNewShot();
      updateStatus(`Round ${match.roundNum} — P${match.activeIndex + 1} starts`);
    }

    // -----------------------------
    // Failsafe timeout (single freeplay only)
    // -----------------------------
    function forceSingleTimeout() {
      if (match.enabled || campaign.enabled) return;
      if (!ball.active) return;
      if (state !== State.FLIGHT && state !== State.RETURNING) return;
      if (state === State.SINGLE_OVER) return;

      showPopup("Timeout", { size: 64, color: "#ffffff" });

      ball.active = false;
      singleShotTimer = 0;

      const pts = 0;
      singleStats.throws++;
      singleStats.sum += pts;
      singleStats.best = (singleStats.best == null) ? pts : Math.max(singleStats.best, pts);
      lastThrowPoints = 0;

      if (singleRunIsOver()) endSingleRun();
      else {
        startNewShot();
        updateStatus("Timeout. Lock POWER.");
      }
    }

    function resolveCatchOrMiss() {
      const hands = getHandsRect();
      const ballRect = { x: ball.x - ball.r, y: ball.y - ball.r, w: ball.r * 2, h: ball.r * 2 };

      if (ball.vy > 0 && rectsOverlap(hands, ballRect)) {
        const pts = shot.pendingPoints;
        ball.active = false;

        if (match.enabled) match.players[match.activeIndex].catches++;
        else if (!campaign.enabled) singleStats.catches++;

        if (pts === 100) {
          showPopup("Walmart 100!", { size: 84, color: "#3b82f6" });
          screenShake = 0.18;
          screenShakeMag = 10;
        }

        if (match.enabled) {
          endTurnWithPoints(pts);
        } else if (campaign.enabled) {
          lastThrowPoints = pts;
          resolveCampaignPoint(pts);
        } else {
          singleStats.throws++;
          singleStats.sum += pts;
          singleStats.best = (singleStats.best == null) ? pts : Math.max(singleStats.best, pts);
          if (pts === 100) singleStats.walmart100s++;

          lastThrowPoints = pts;
          singleShotTimer = 0;

          if (singleRunIsOver()) endSingleRun();
          else {
            startNewShot();
            updateStatus("Caught! Lock POWER.");
          }
        }
        return;
      }

      if (ball.y + ball.r >= floorY) {
        showPopup("Missed Catch", { size: 64, color: "#ffffff" });

        ball.active = false;

        if (match.enabled) {
          endTurnWithPoints(0);
        } else if (campaign.enabled) {
          lastThrowPoints = 0;
          resolveCampaignPoint(0);
        } else {
          const pts = 0;
          singleStats.throws++;
          singleStats.sum += pts;
          singleStats.best = (singleStats.best == null) ? pts : Math.max(singleStats.best, pts);

          lastThrowPoints = 0;
          singleShotTimer = 0;

          if (singleRunIsOver()) endSingleRun();
          else {
            startNewShot();
            updateStatus("Missed catch. Lock POWER.");
          }
        }
        return;
      }
    }

    function update(dt) {
      if (state === State.TITLE) { updatePopup(dt); return; }
      updatePopup(dt);

      if (screenShake > 0) screenShake = Math.max(0, screenShake - dt);

      const canPlay =
        (!match.enabled || match.started) &&
        (!campaign.enabled || campaign.started);

      if (arena.level && state !== State.MATCH_OVER && state !== State.SINGLE_OVER && state !== State.CAMPAIGN_OVER && canPlay) {
        updatePlayer(dt);
      }

      if (state === State.POWER_METER) {
        resetBallToHand();
        meterStep(dt, effectivePowerSpeed());
      } else if (state === State.ANGLE_METER) {
        resetBallToHand();
        meterStep(dt, effectiveAngleSpeed());
      } else if (state === State.FLIGHT) {
        updateBall(dt);
        if (!match.enabled && !campaign.enabled && ball.active) {
          singleShotTimer -= dt;
          if (singleShotTimer <= 0) forceSingleTimeout();
        }
      } else if (state === State.RETURNING) {
        updateBall(dt);
        resolveCatchOrMiss();
        if (!match.enabled && !campaign.enabled && ball.active) {
          singleShotTimer -= dt;
          if (singleShotTimer <= 0) forceSingleTimeout();
        }
      }
    }

    // -----------------------------
    // Drawing
    // -----------------------------
    function drawPowerMeter() {
      const pad = 16;
      const barW = 560;
      const barH = 18;
      const x = (W - barW) / 2;
      const y = 18;

      ctx.fillStyle = "rgba(15, 23, 42, 0.08)";
      ctx.fillRect(x - pad, y - pad, barW + pad * 2, 92);

      ctx.fillStyle = arena.theme.ui;
      ctx.font = "18px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("POWER METER", W / 2, y + 8);

      const barY = y + 28;
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.fillRect(x, barY, barW, barH);

      const mx = x + meter.value * barW;

      ctx.save();
      ctx.shadowColor = "rgba(239,68,68,0.08)";
      ctx.shadowBlur = 0.5;

      ctx.strokeStyle = "#ef4444";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(mx, barY - 8);
      ctx.lineTo(mx, barY + barH + 8);
      ctx.stroke();
      ctx.restore();

      ctx.fillStyle = arena.theme.ui;
      ctx.font = "13px system-ui";
      ctx.textAlign = "left";
      ctx.fillText("Low", x, barY + barH + 24);
      ctx.textAlign = "right";
      ctx.fillText("High", x + barW, barY + barH + 24);

      ctx.textAlign = "center";
      ctx.font = "14px system-ui";
      ctx.fillText("Tap or press SPACE to lock", W / 2, barY + barH + 46);
    }

    function drawAngleMeterVertical() {
      const pad = 16;
      const barH = 300;
      const barW = 18;

      const x = wallX - 70;
      const y = (H - barH) / 2;

      ctx.fillStyle = "rgba(15, 23, 42, 0.08)";
      ctx.fillRect(x - pad, y - pad, barW + pad * 2, barH + 90);

      ctx.fillStyle = arena.theme.ui;
      ctx.font = "18px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("ANGLE METER", x + barW / 2, y - 6);

      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.fillRect(x, y, barW, barH);

      const my = y + (1 - meter.value) * barH;

      ctx.save();
      ctx.shadowColor = "rgba(239,68,68,0.14)";
      ctx.shadowBlur = 2;

      ctx.strokeStyle = "#ef4444";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(x - 8, my);
      ctx.lineTo(x + barW + 8, my);
      ctx.stroke();
      ctx.restore();

      ctx.fillStyle = arena.theme.ui;
      ctx.font = "13px system-ui";
      ctx.textAlign = "left";
      ctx.fillText("-60°", x - 18, y - 14);
      ctx.fillText("-90°", x - 18, y + barH + 16);

      ctx.textAlign = "center";
      ctx.font = "14px system-ui";
      ctx.fillText("Tap or press SPACE", x + barW / 2, y + barH + 42);
    }

    function drawRoof() {
      if (arena.roofType === "none") return;

      const y0 = roofAtX(playLeft);
      const y1 = roofAtX(wallX);

      ctx.strokeStyle = "#000";
      ctx.lineWidth = 18;
      ctx.beginPath();
      ctx.moveTo(playLeft, y0);
      ctx.lineTo(wallX, y1);
      ctx.stroke();

      ctx.strokeStyle = arena.theme.roof;
      ctx.lineWidth = 12;
      ctx.beginPath();
      ctx.moveTo(playLeft, y0);
      ctx.lineTo(wallX, y1);
      ctx.stroke();

      if (arena.level?.id === 0) {
        ctx.strokeStyle = "rgba(0,0,0,0.25)";
        ctx.lineWidth = 16;
        ctx.beginPath();
        ctx.moveTo(playLeft, y0 + 6);
        ctx.lineTo(wallX, y1 + 6);
        ctx.stroke();
      }
    }

    function drawCharacter(x, y, w, h, outfit) {
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.25)";
      ctx.shadowBlur = 12;
      ctx.shadowOffsetY = 6;

      const hairH  = h * 0.10;
      const faceH  = h * 0.25;
      const shirtH = h * 0.30;
      const pantsH = h * 0.35;

      ctx.fillStyle = outfit.hair;
      ctx.fillRect(x, y, w, hairH);

      ctx.fillStyle = outfit.face;
      ctx.fillRect(x, y + hairH, w, faceH);

      ctx.fillStyle = outfit.shirt;
      ctx.fillRect(x, y + hairH + faceH, w, shirtH);

      ctx.fillStyle = outfit.pants;
      ctx.fillRect(x, y + hairH + faceH + shirtH, w, pantsH);

      ctx.strokeStyle = outfit.outline ?? "#111827";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, w, h);

      const eyeY = y + hairH + faceH * 0.48;
      const eyeDX = w * 0.18;
      const eyeR = Math.max(1.8, Math.min(3.2, w * 0.03));

      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.beginPath();
      ctx.arc(x + w * 0.5 - eyeDX, eyeY, eyeR, 0, Math.PI * 2);
      ctx.arc(x + w * 0.5 + eyeDX, eyeY, eyeR, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function panelHitTestPlayerBlocks(mx, my) {
      if (!match.enabled || match.started) return null;
      if (mx > PANEL_W) return null;

      const blockY = 130;
      const blockH = 270;
      const gap = 300;

      const p1Top = blockY - 30;
      const p1Bot = p1Top + blockH;
      const p2Top = blockY + gap - 30;
      const p2Bot = p2Top + blockH;

      if (my >= p1Top && my <= p1Bot) return 0;
      if (my >= p2Top && my <= p2Bot) return 1;
      return null;
    }

    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const my = (e.clientY - rect.top) * (canvas.height / rect.height);

      const hit = panelHitTestPlayerBlocks(mx, my);
      if (hit != null) {
        match.setupPickIndex = hit;
        const cid = match.players[hit].characterId ?? 0;
        currentCharacter = CHARACTERS[cid] ?? CHARACTERS[0];
        updateCharacterButtons();
        updateStatus(`Assigning for P${hit + 1} (click character buttons)`);
        refreshBeginButton();
      }
    });

    function drawSidePanel() {
      ctx.fillStyle = "#0b1220";
      ctx.fillRect(0, 0, PANEL_W, H);

      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(PANEL_W - 2, 0, 2, H);

      ctx.fillStyle = "#e5e7eb";
      ctx.textAlign = "left";

      ctx.font = "18px system-ui";
      ctx.fillText(match.enabled ? "2P HOTSEAT" : (campaign.enabled ? "CAMPAIGN" : "SINGLE"), 14, 28);

      ctx.font = "14px system-ui";

      if (campaign.enabled) {
        const opp = campaignOpponent();
        ctx.fillText(`Opponent: ${opp.name}`, 14, 52);
        ctx.fillText(`Stage: ${campaign.opponentIndex + 1}/8`, 14, 72);
        ctx.fillText(`Score: ${campaign.pScore}-${campaign.oScore}`, 14, 92);

        const starter = campaign.pointStarter === 0 ? "Opp first" : "You first";
        ctx.fillText(`Next: ${starter}`, 14, 112);

        ctx.fillText(`You: ${currentCharacter?.name ?? "-"}`, 14, 136);

        const oppChar = CHARACTERS[campaign.oppCharId ?? 0];
        if (oppChar) ctx.fillText(`Vs: ${oppChar.name} (${tiersTextFor(oppChar)})`, 14, 156);

        if (!campaign.started && state !== State.CAMPAIGN_OVER) {
          ctx.fillStyle = "rgba(255,255,255,0.85)";
          ctx.fillText("Press Begin to start", 14, 182);
        }

        if (state === State.CAMPAIGN_OVER) {
          ctx.fillStyle = "rgba(15,23,42,0.85)";
          ctx.fillRect(8, H - 160, PANEL_W - 16, 140);
          ctx.fillStyle = "#ffffff";
          ctx.textAlign = "center";
          ctx.font = "18px system-ui";

          if (campaign.lastResult === "COMPLETE") {
            ctx.fillText("CAMPAIGN COMPLETE!", PANEL_W / 2, H - 120);
            ctx.font = "14px system-ui";
            ctx.fillText("You beat Ethan.", PANEL_W / 2, H - 92);
            ctx.fillText("Press R to restart", PANEL_W / 2, H - 62);
          } else if (campaign.lastResult === "WIN") {
            ctx.fillText("YOU WIN!", PANEL_W / 2, H - 120);
            ctx.font = "14px system-ui";
            ctx.fillText(`Next: ${campaignOpponent().name}`, PANEL_W / 2, H - 92);
            ctx.fillText("Press Begin to play", PANEL_W / 2, H - 62);
          } else {
            ctx.fillText("YOU LOSE", PANEL_W / 2, H - 120);
            ctx.font = "14px system-ui";
            ctx.fillText(`Replay: ${campaignOpponent().name}`, PANEL_W / 2, H - 92);
            ctx.fillText("Press Begin to retry", PANEL_W / 2, H - 62);
          }
          ctx.textAlign = "left";
        }

        return;
      }

      if (match.enabled) {
        ctx.fillText(`Round: ${match.roundNum}`, 14, 52);
        ctx.fillText(`First to: ${match.roundsToWin}`, 14, 72);
        ctx.fillText(match.started ? `Turn: P${match.activeIndex + 1}` : `Setup: click P1/P2`, 14, 92);

        const blockY = 130;
        const blockH = 270;

        function drawPlayerBlock(i, y) {
          const p = match.players[i];
          const ch = (p.characterId != null) ? CHARACTERS[p.characterId] : null;

          const isActive = match.started && match.activeIndex === i && state !== State.MATCH_OVER;
          const isSetupSel = !match.started && match.setupPickIndex === i;

          if (isActive) {
            ctx.fillStyle = "rgba(34, 197, 94, 0.16)";
            ctx.fillRect(10, y - 22, PANEL_W - 20, blockH);
          } else if (isSetupSel) {
            ctx.fillStyle = "rgba(250, 204, 21, 0.14)";
            ctx.fillRect(10, y - 22, PANEL_W - 20, blockH);
          }

          ctx.fillStyle = "#e5e7eb";
          ctx.font = "16px system-ui";
          ctx.fillText(`${p.name}`, 14, y);

          ctx.font = "13px system-ui";
          if (ch) ctx.fillText(`Char: ${ch.name} (${tiersTextFor(ch)})`, 14, y + 22);
          else ctx.fillText(`Char: (pick one)`, 14, y + 22);

          ctx.font = "54px system-ui";
          ctx.fillText(`${p.roundsWon}`, 14, y + 82);
          ctx.font = "13px system-ui";
          ctx.fillText("ROUNDS", 14, y + 102);

          const avg = p.throws > 0 ? (p.sum / p.throws) : 0;
          const pct = p.attempts > 0 ? Math.round((p.catches / p.attempts) * 100) : 0;
          const best = (p.best == null) ? "-" : p.best;

          ctx.font = "14px system-ui";
          ctx.fillText(`Avg: ${avg.toFixed(1)}`, 14, y + 132);
          ctx.fillText(`Catch%: ${pct}%`, 14, y + 154);
          ctx.fillText(`Best: ${best}`, 14, y + 176);
          ctx.fillText(`Walmart100s: ${p.walmart100s}`, 14, y + 198);
          ctx.fillText(`Layups: ${p.layups}`, 14, y + 220);

          const s = match.roundShots[i];
          ctx.fillText(`This round: ${s == null ? "…" : s}`, 14, y + 242);
          ctx.fillText(`Last: ${p.lastThrow ?? "-"}`, 14, y + 264);
        }

        drawPlayerBlock(0, blockY);
        drawPlayerBlock(1, blockY + 300);

        if (state === State.MATCH_OVER && match.winnerIndex != null) {
          ctx.fillStyle = "rgba(15,23,42,0.85)";
          ctx.fillRect(8, H - 150, PANEL_W - 16, 130);

          ctx.fillStyle = "#ffffff";
          ctx.textAlign = "center";
          ctx.font = "18px system-ui";
          ctx.fillText(`WINNER: ${match.players[match.winnerIndex].name}`, PANEL_W / 2, H - 112);

          ctx.font = "14px system-ui";
          ctx.fillText(`Final: ${match.players[0].roundsWon}–${match.players[1].roundsWon}`, PANEL_W / 2, H - 86);
          ctx.fillText("Press R to reset", PANEL_W / 2, H - 56);
          ctx.textAlign = "left";
        }

        return;
      }

      const avg = avgScore(singleStats);
      const best = singleStats.best ?? "-";
      const pct = Math.round(catchPct(singleStats) * 100);

      ctx.fillText(`Avg: ${avg.toFixed(1)}`, 14, 52);
      ctx.fillText(`Best: ${best}`, 14, 72);
      ctx.fillText(`Catch%: ${pct}%`, 14, 92);
      ctx.fillText(`Walmart100s: ${singleStats.walmart100s}`, 14, 112);
      ctx.fillText(currentCharacter ? `Char: ${currentCharacter.name}` : "", 14, 132);
    }

    function drawTitleScreen() {
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = "rgba(15, 23, 42, 0.75)";
      ctx.fillRect(W/2 - 360, H/2 - 170, 720, 340);

      ctx.textAlign = "center";
      ctx.fillStyle = "#ffffff";

      ctx.font = "bold 86px Trebuchet MS, system-ui";
      ctx.fillText("BIG BOUNCE", W/2, H/2 - 40);

      ctx.font = "bold 22px Trebuchet MS, system-ui";
      ctx.fillText("Tap or Press SPACE to Start", W/2, H/2 + 20);

      ctx.font = "16px Trebuchet MS, system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillText("Hotseat: pick level + characters (P1/P2), then Begin Game.", W/2, H/2 + 64);
      ctx.fillText("Campaign: pick level + your character, then Begin Campaign Match.", W/2, H/2 + 92);

      ctx.textAlign = "left";
    }

    function drawSingleOverOverlay() {
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(playLeft, 0, W - playLeft, H);

      const cardW = 740;
      const cardH = 360;
      const cx = playLeft + (W - playLeft) / 2;
      const cy = H / 2;

      ctx.fillStyle = "rgba(15, 23, 42, 0.78)";
      ctx.fillRect(cx - cardW/2, cy - cardH/2, cardW, cardH);

      const total = singleStats.sum;
      const avg = avgScore(singleStats);
      const best = singleStats.best ?? "-";
      const pct = Math.round(catchPct(singleStats) * 100);
      const w100 = singleStats.walmart100s;

      ctx.textAlign = "center";
      ctx.fillStyle = "#ffffff";

      ctx.font = "900 64px Trebuchet MS, system-ui";
      ctx.fillText("RUN OVER", cx, cy - 110);

      ctx.font = "700 24px Trebuchet MS, system-ui";
      ctx.fillText(`Turns: ${Math.min(singleStats.attempts, SINGLE_TURNS)}/${SINGLE_TURNS}`, cx, cy - 68);

      ctx.font = "22px Trebuchet MS, system-ui";
      ctx.fillText(`Total Points: ${total}`, cx, cy - 18);
      ctx.fillText(`Avg: ${avg.toFixed(1)}   |   Best: ${best}`, cx, cy + 20);
      ctx.fillText(`Catch%: ${pct}%   |   Walmart100s: ${w100}`, cx, cy + 58);

      ctx.font = "18px Trebuchet MS, system-ui";
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillText("Press R to restart run", cx, cy + 120);

      ctx.textAlign = "left";
    }

    function drawCampaignOverOverlay() {
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(playLeft, 0, W - playLeft, H);

      const cardW = 820;
      const cardH = 320;
      const cx = playLeft + (W - playLeft) / 2;
      const cy = H / 2;

      ctx.fillStyle = "rgba(15, 23, 42, 0.78)";
      ctx.fillRect(cx - cardW/2, cy - cardH/2, cardW, cardH);

      ctx.textAlign = "center";
      ctx.fillStyle = "#ffffff";

      const oppName = campaignOpponent().name;

      if (campaign.lastResult === "COMPLETE") {
        ctx.font = "900 56px Trebuchet MS, system-ui";
        ctx.fillText("CAMPAIGN COMPLETE", cx, cy - 70);
        ctx.font = "700 22px Trebuchet MS, system-ui";
        ctx.fillText("You beat Ethan.", cx, cy - 22);
        ctx.font = "18px Trebuchet MS, system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillText("Press R to restart the campaign", cx, cy + 66);
      } else if (campaign.lastResult === "WIN") {
        ctx.font = "900 56px Trebuchet MS, system-ui";
        ctx.fillText("YOU WIN", cx, cy - 70);
        ctx.font = "700 22px Trebuchet MS, system-ui";
        ctx.fillText(`Next opponent: ${oppName}`, cx, cy - 22);
        ctx.font = "18px Trebuchet MS, system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillText("Press Begin to play the next match", cx, cy + 66);
      } else {
        ctx.font = "900 56px Trebuchet MS, system-ui";
        ctx.fillText("YOU LOSE", cx, cy - 70);
        ctx.font = "700 22px Trebuchet MS, system-ui";
        ctx.fillText(`Replay opponent: ${oppName}`, cx, cy - 22);
        ctx.font = "18px Trebuchet MS, system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillText("Press Begin to retry", cx, cy + 66);
      }

      ctx.textAlign = "left";
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);

      ctx.save();
      if (screenShake > 0) {
        const dx = (Math.random() - 0.5) * 2 * screenShakeMag;
        const dy = (Math.random() - 0.5) * 2 * screenShakeMag;
        ctx.translate(dx, dy);
      }

      drawSidePanel();

      // Background
      const bgTop = arena.theme?.bg ?? "#f8fafc";

      if (arena.level?.id === 3) {
        ctx.fillStyle = bgTop;
      } else {
        const bgBottom = "rgba(0,0,0,0.06)";
        const grad = ctx.createLinearGradient(0, 0, 0, H);
        grad.addColorStop(0, bgTop);
        grad.addColorStop(1, bgBottom);
        ctx.fillStyle = grad;
      }

      ctx.fillRect(playLeft, 0, W - playLeft, H);

      // Background props (BEHIND everything)
      drawMoonBackgroundProps();       // ✅ NEW (Moon: earth + stars)
      drawBerlinBackgroundProps();
      drawTownhouseBackgroundProps();
      drawSquashBackgroundProps();


      drawRoof();

      // FLOOR
      ctx.fillStyle = arena.theme?.floor;
      ctx.fillRect(playLeft, floorY, W - playLeft, H - floorY);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 3;
      ctx.strokeRect(playLeft, floorY, W - playLeft, H - floorY);

      // WALL
      ctx.fillStyle = arena.theme?.wall;
      ctx.fillRect(wallX, arena.wallTopY, W - wallX, floorY - arena.wallTopY);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 3;
      ctx.strokeRect(wallX, arena.wallTopY, W - wallX, floorY - arena.wallTopY);

      if (arena.level?.id === 2) {
        drawConcreteTexture(playLeft, floorY, W - playLeft, H - floorY);
        drawConcreteTexture(wallX, arena.wallTopY, W - wallX, floorY - arena.wallTopY);
      }

      const outfit = currentCharacter?.outfit ?? DEFAULT_OUTFIT;
      drawCharacter(player.x, player.y, player.w, player.h, outfit);

      const hands = getHandsRect();
      ctx.fillStyle = "rgba(34, 197, 94, 0.35)";
      ctx.fillRect(hands.x, hands.y, hands.w, hands.h);
      ctx.strokeStyle = "rgba(15, 23, 42, 0.75)";
      ctx.lineWidth = 2;
      ctx.strokeRect(hands.x, hands.y, hands.w, hands.h);

      // Ball shadow + glow + spin seam
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.3)";
      ctx.shadowBlur = 8;
      ctx.shadowOffsetY = 4;

      if (ball.active && (shot?.pendingPoints ?? 0) > 0 && !shot.invalid) {
        ctx.shadowColor = "rgba(59,130,246,0.6)";
        ctx.shadowBlur = 20;
      }

      ctx.translate(ball.x, ball.y);
      ctx.rotate(ball.spin);

      ctx.beginPath();
      ctx.fillStyle = "#ef4444";
      ctx.strokeStyle = "#111827";
      ctx.lineWidth = 2;
      ctx.arc(0, 0, ball.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = "rgba(255,255,255,0.65)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, ball.r * 0.65, -0.6, 0.8);
      ctx.stroke();

      ctx.restore();

      if (lastWallHitY != null) {
        ctx.strokeStyle = "#ef4444";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(wallX, lastWallHitY);
        ctx.lineTo(wallX + 30, lastWallHitY);
        ctx.stroke();
      }

      if (state === State.SELECT_LEVEL) {
        ctx.fillStyle = "rgba(15, 23, 42, 0.10)";
        ctx.fillRect(W/2 - 360, H/2 - 70, 720, 140);
        ctx.fillStyle = arena.theme.ui;
        ctx.textAlign = "center";
        ctx.font = "22px system-ui";
        const msg = match.enabled
          ? "Pick a Level, Assign P1/P2, then Begin Game"
          : campaign.enabled
            ? "Campaign: Pick a Level + Your Character, then Begin"
            : "Select a Level Above to Start";
        ctx.fillText(msg, W/2, H/2 - 10);
        ctx.font = "14px system-ui";
        ctx.fillText("Townhouse = angled roof | Moon = low gravity | Berlin Wall = no roof + tall wall", W/2, H/2 + 20);
        ctx.textAlign = "left";
      }

      if (state === State.POWER_METER) drawPowerMeter();
      else if (state === State.ANGLE_METER) drawAngleMeterVertical();
      else if (state === State.FLIGHT || state === State.RETURNING) {
        ctx.fillStyle = "rgba(15,23,42,0.08)";
        ctx.fillRect(W/2 - 280, 18, 560, 42);
        ctx.fillStyle = arena.theme.ui;
        ctx.textAlign = "center";
        ctx.font = "16px system-ui";
        ctx.fillText("Move ← → and jump ↑ to catch the ball", W/2, 46);
        ctx.textAlign = "left";
      }

      if (match.enabled && match.started && state !== State.MATCH_OVER) {
        ctx.fillStyle = "rgba(15,23,42,0.10)";
        ctx.fillRect(playLeft + 10, 10, 320, 44);
        ctx.fillStyle = arena.theme.ui;
        ctx.textAlign = "left";
        ctx.font = "18px system-ui";
        ctx.fillText(`TURN: P${match.activeIndex + 1}`, playLeft + 22, 38);
      }

      drawPopup();

      if (state === State.SINGLE_OVER) drawSingleOverOverlay();
      if (state === State.CAMPAIGN_OVER) drawCampaignOverOverlay();
      if (state === State.TITLE) drawTitleScreen();

      ctx.restore();
    }

    // -----------------------------
    // Loop
    // -----------------------------
    let last = performance.now();
    function loop(t) {
      const dt = Math.min(0.033, (t - last) / 1000);
      last = t;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // -----------------------------
    // Init
    // -----------------------------
    function initButtons() {
      document.getElementById("modeSingle").classList.toggle("active", true);
      document.getElementById("modeMulti").classList.toggle("active", false);
      document.getElementById("modeCampaign").classList.toggle("active", false);
    }

    // -----------------------------
    // Responsive canvas sizing
    // -----------------------------
    function resizeCanvas() {
      const touchControls = document.getElementById("touch-controls");
      const isMobile = touchControls && window.getComputedStyle(touchControls).display !== "none";
      const hud = document.querySelector(".hud");
      const hudHeight = hud ? hud.offsetHeight : 0;
      const controlsHeight = isMobile ? 150 : 0;
      const availW = window.innerWidth;
      const availH = window.innerHeight - hudHeight - controlsHeight;

      const aspect = W / H;
      let drawW = availW;
      let drawH = drawW / aspect;

      if (drawH > availH) {
        drawH = availH;
        drawW = drawH * aspect;
      }

      canvas.style.width = Math.floor(drawW) + "px";
      canvas.style.height = Math.floor(drawH) + "px";
    }

    window.addEventListener("resize", resizeCanvas);
    window.addEventListener("orientationchange", () => { setTimeout(resizeCanvas, 100); });

    initButtons();
    setMode(Mode.SINGLE);
    updateCharacterButtons();
    resetGame();
    state = State.TITLE;
    updateStatus("Tap or press SPACE to start.");
    refreshBeginButton();
    resizeCanvas();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
